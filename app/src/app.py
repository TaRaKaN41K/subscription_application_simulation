import customtkinter as ctkimport requestsimport uuidfrom datetime import datetime, timedeltaimport timeimport subprocessdef close_and_uninstall(subscription_window, app_instance):    subscription_window.destroy()    app_instance.destroy()    try:        uninstall_script_path = 'src/uninstall.py'        subprocess.run(['python3', uninstall_script_path])    except Exception as e:        print(f"Error during uninstallation: {e}")class App(ctk.CTk):    def __init__(self):        super().__init__()        self.geometry("500x400")        self.title("tarakans.app")        self.resizable(False, False)        self.countdown_label = ctk.CTkLabel(self,                                            text="Enter your full name",                                            text_color="gray",                                            font=("Helvetica", 20))        self.countdown_label.pack(pady=50)        self.full_name_entry = ctk.CTkEntry(self,                                            font=("Helvetica", 14))        self.full_name_entry.pack(pady=50)        self.full_name_entry.bind("<Return>", self.get_and_clear_text)        self.start_limit_label = ctk.CTkLabel(self,                                              text="Start Limit:",                                              text_color="white",                                              font=("Helvetica", 10))        self.start_limit_label.pack(pady=10)        self.time_limit_label = ctk.CTkLabel(self,                                             text="Time Limit:",                                             text_color="white",                                             font=("Helvetica", 10))        self.time_limit_label.pack(pady=10)    def show_subscription_window(self):        subscription_window = ctk.CTk()        subscription_window.title("tarakans.app Subscription")        subscription_window.geometry("300x150")        subscription_window.resizable(False, False)        subscription_label = ctk.CTkLabel(subscription_window,                                          text="Please purchase a subscription",                                          text_color="gray",                                          font=("Helvetica", 20))        subscription_label.pack(pady=40)        delete_button = ctk.CTkButton(subscription_window,                                      text="Delete tarakans.app",                                      text_color="white",                                      fg_color="gray",                                      hover_color="black",                                      command=lambda: close_and_uninstall(subscription_window, self))        delete_button.pack(pady=0)        subscription_window.mainloop()    def send_user_info(self, user_input):        user_mac_addr = uuid.getnode()        get_url = f'http://127.0.0.1:5000/get_user_info?mac_addr={user_mac_addr}'        resp = requests.get(get_url)        self.update_limits_info(resp.json()['time_limit'], resp.json()['start_limit'])        if ((time.time() <= resp.json()['time_limit']) and                (resp.json()['start_limit'] != 0)):            try:                with open('user_info.txt', 'r') as file:                    data = file.read()                    if user_input in data:                        print("Данные о пользователе уже присутствуют в файле.")                    else:                        with open('user_info.txt', 'a') as file1:                            file1.write(user_input + '\n')                            update_data = {                                'mac_addr': user_mac_addr,  # Исправлено на user_mac_addr                                'start_limit': int(resp.json()['start_limit']) - 1                            }                            url_update = 'http://127.0.0.1:5000/update'                            requests.post(url_update, json=update_data)                            self.update_limits_info(resp.json()['time_limit'], int(resp.json()['start_limit']) - 1)                            print("Информация о пользователе успешно добавлена.")            except FileNotFoundError:                with open('user_info.txt', 'w') as file:                    file.write(user_input + '\n')                    update_data = {                        'mac_addr': user_mac_addr,  # Исправлено на user_mac_addr                        'start_limit': int(resp.json()['start_limit']) - 1                    }                    url_update = 'http://127.0.0.1:5000/update'                    requests.post(url_update, json=update_data)                    self.update_limits_info(resp.json()['time_limit'], int(resp.json()['start_limit']) - 1)                    print("Информация о пользователе успешно добавлена.")        else:            self.show_subscription_window()    def get_and_clear_text(self, event):        user_text = self.full_name_entry.get()        if user_text:            self.send_user_info(user_text)            self.full_name_entry.delete(0, 'end')            return user_text    def update_limits_info(self, time_lim, start):        start_limit = start        time_limit = datetime.fromtimestamp(time_lim).strftime('%Y-%m-%d %H:%M:%S')        self.start_limit_label.configure(text=f"Start Limit: {start_limit}")        self.time_limit_label.configure(text=f"Time Limit: {time_limit}")if __name__ == "__main__":    current_time = datetime.now()    user_mac_addr = uuid.getnode()  # Исправлено на user_mac_addr    time_limit = (current_time + timedelta(minutes=1)).timestamp()    add_data = {        'mac_addr': user_mac_addr,  # Исправлено на user_mac_addr        'time_limit': time_limit,        'start_limit': 3    }    add_url = 'http://127.0.0.1:5000/add'    requests.post(add_url, json=add_data)    app = App()    user_mac_addr = uuid.getnode()    get_url = f'http://127.0.0.1:5000/get_user_info?mac_addr={user_mac_addr}'    resp = requests.get(get_url)    app.update_limits_info(resp.json()['time_limit'], resp.json()['start_limit'])    app.mainloop()